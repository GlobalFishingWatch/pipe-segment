#standardSQL
WITH
  #
  #  Pull out the segments we want to work with
  #
  segs AS (
    SELECT
      CAST (ssvid AS string) ssvid,
      seg_id,
      MIN(timestamp_min) min_ts,
      MAX(timestamp_max) max_ts,
      LOGICAL_OR(noise) as noise,
      sum(message_count) as message_count
    FROM
       `world-fishing-827.pipe_staging_a.segments_2017*`
    WHERE
      _table_suffix BETWEEN '1201'
      AND '1231'
--       `world-fishing-827.pipe_staging_a.segments_*`
--     WHERE
--       _table_suffix BETWEEN '20171201'
--       AND '20171201'
    GROUP BY
      ssvid,
      seg_id
    ),
  noise_segs as (
    select
      * except(noise),
      noise or message_count <= 3 as noise
    from
      segs
  ),
  #
  #  Order the segments by timestamp, and ignore noise segments
  #
  ordered_segs AS (
  SELECT
    ssvid,
    max_ts AS end_ts,
    LEAD(min_ts) OVER (PARTITION BY ssvid ORDER BY min_ts) AS next_start_ts
  FROM
    noise_segs
  where
    not noise),
  #
  #  Find SSVIDs that do not have any segments that overlap in time
  #
  no_overlap_ssvid AS (
  SELECT
    ssvid,
    COUNTIF(end_ts > next_start_ts) AS overlap_count
  FROM
    ordered_segs
  GROUP BY
    ssvid
  having
    overlap_count = 0),
  #
  #  Get montly identity message summaries
  #
  identity_messages_monthly AS (
  SELECT
    CAST(ssvid AS string) AS ssvid,
    seg_id,
    n_shipname,
    n_callsign,
    cast(n_imo as string) as n_imo,
    msg_count,
    pos_count,
    first_timestamp,
    last_timestamp
  FROM
    `world-fishing-827.pipe_staging_a.identity_messages_monthly_20171201` ),
  #
  #  Get SSVIDs from identity_messages_monthly that have at most
  #  one non-null value for shipname, callsign and imo
  #
  single_ident_ssvid AS (
  SELECT
    CAST (ssvid AS STRING) AS ssvid,
    COUNT(DISTINCT n_shipname) AS shipname_count,
    COUNT( DISTINCT n_callsign) AS callsign_count,
    COUNT(DISTINCT n_imo) AS imo_count
  FROM
    identity_messages_monthly
  GROUP BY
    ssvid
  HAVING
    shipname_count <= 1
    AND callsign_count <= 1
    AND imo_count <= 1 ),
  #
  #  Get the intersection of the non-overlay ssvids and the ones with at most one
  #  shipname, callsign and imo.  This is the set of ssvid that are free of spoofing and
  #  have only one identity for the time period
  #
  no_spoof_single_ident_ssvid AS (
  SELECT
    ssvid, True as single_id
  FROM
    single_ident_ssvid
  JOIN
    no_overlap_ssvid
  USING
    (ssvid) ),

  #
  # suppress msg_count for null values
  #
  identity_count_not_null AS (
  SELECT
    *,
    if(n_shipname is null, 0, msg_count) as shipname_msg_count,
    if(n_callsign is null, 0, msg_count) as callsign_msg_count,
    if(n_imo is null, 0, msg_count) as imo_msg_count
  FROM
    identity_messages_monthly ),

  #
  # Get message counts for the identity field values
  #
  identity_count AS (
  SELECT
    *,
    SUM(shipname_msg_count) OVER (PARTITION BY ssvid, n_shipname) AS ssvid_shipname_msg_count,
    SUM(callsign_msg_count) OVER (PARTITION BY ssvid, n_callsign) AS ssvid_callsign_msg_count,
    SUM(imo_msg_count) OVER (PARTITION BY ssvid, n_imo) AS ssvid_imo_msg_count,
    SUM(shipname_msg_count) OVER (PARTITION BY ssvid, seg_id, n_shipname) AS segid_shipname_msg_count,
    SUM(callsign_msg_count) OVER (PARTITION BY ssvid, seg_id, n_callsign) AS segid_callsign_msg_count,
    SUM(imo_msg_count) OVER (PARTITION BY ssvid, seg_id, n_imo) AS segid_imo_msg_count
  FROM
    identity_count_not_null ),
  #
  # Get the most common identity fields by seg_id and by ssvid
  #
  most_common AS (
  SELECT
    *,
    STRUCT(
      FIRST_VALUE(n_shipname IGNORE NULLS) OVER (PARTITION BY ssvid ORDER BY ssvid_shipname_msg_count DESC) AS n_shipname,
      FIRST_VALUE(ssvid_shipname_msg_count) OVER (PARTITION BY ssvid ORDER BY ssvid_shipname_msg_count DESC) AS n_shipname_count,

      FIRST_VALUE(n_callsign IGNORE NULLS) OVER (PARTITION BY ssvid ORDER BY ssvid_callsign_msg_count DESC) AS n_callsign,
      FIRST_VALUE(ssvid_callsign_msg_count IGNORE NULLS) OVER (PARTITION BY ssvid ORDER BY ssvid_callsign_msg_count DESC) AS n_callsign_count,

      FIRST_VALUE(n_imo IGNORE NULLS) OVER (PARTITION BY ssvid ORDER BY ssvid_imo_msg_count DESC) AS n_imo,
      FIRST_VALUE(ssvid_imo_msg_count IGNORE NULLS) OVER (PARTITION BY ssvid ORDER BY ssvid_imo_msg_count DESC) AS n_imo_count
    ) as ssvid_ident,

    STRUCT(
      FIRST_VALUE(n_shipname IGNORE NULLS) OVER (PARTITION BY ssvid, seg_id ORDER BY segid_shipname_msg_count DESC) AS n_shipname,
      FIRST_VALUE(segid_shipname_msg_count IGNORE NULLS) OVER (PARTITION BY ssvid, seg_id ORDER BY segid_shipname_msg_count DESC) AS n_shipname_count,

      FIRST_VALUE(n_callsign IGNORE NULLS) OVER (PARTITION BY ssvid, seg_id ORDER BY segid_callsign_msg_count DESC) AS n_callsign,
      FIRST_VALUE(segid_callsign_msg_count IGNORE NULLS) OVER (PARTITION BY ssvid, seg_id ORDER BY segid_callsign_msg_count DESC) AS n_callsign_count,

      FIRST_VALUE(n_imo IGNORE NULLS) OVER (PARTITION BY ssvid, seg_id ORDER BY segid_imo_msg_count DESC) AS n_imo,
      FIRST_VALUE(segid_imo_msg_count IGNORE NULLS) OVER (PARTITION BY ssvid, seg_id ORDER BY segid_imo_msg_count DESC) AS n_imo_count
    ) as segid_ident

  FROM
    identity_count ),
  #
  #  Group the most common identity fields to one per seg_id
  #
  most_common_by_seg_id AS (
  SELECT
    ssvid,
    seg_id,
    sum(msg_count) as msg_count,
    sum(pos_count) as pos_count,
    min(first_timestamp) as first_timestamp,
    max(last_timestamp) as last_timestamp,
    ANY_VALUE(ssvid_ident) AS ssvid_ident,
    ANY_VALUE(segid_ident) AS segid_ident
  FROM
    most_common
  GROUP BY
    ssvid,
    seg_id ),

  #
  # Combine most common identity values with segment overlap
  #
  most_common_with_overlap AS (
  SELECT
    ssvid,
    seg_id,
    msg_count,
    pos_count,
    first_timestamp,
    last_timestamp,
    noise,
    IF(single_id,
      ssvid_ident,
      segid_ident) AS ident
  FROM
    most_common_by_seg_id
  JOIN
    noise_segs
  USING
    (ssvid, seg_id)
  LEFT JOIN
    no_spoof_single_ident_ssvid
  USING
    (ssvid)
  ),

  #
  #  Pull it all together with each segment having the complete set of identifiers
  #
  segment_identity as (
    select
      * except (ident),
      ident.*,
      if(ident.n_imo is not null,
       TO_HEX(MD5(FORMAT("AIS|%s|%s|%s|%s", ssvid, ident.n_imo, '', ''))),
       TO_HEX(MD5(FORMAT("AIS|%s|%s|%s|%s", ssvid, '', ifnull(ident.n_shipname, ''), ifnull(ident.n_callsign, ''))))
      ) AS vessel_id

    from
      most_common_with_overlap
  )


SELECT
  *
FROM
  segment_identity
